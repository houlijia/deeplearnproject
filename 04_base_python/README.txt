1、 is和==的区别
    is：判断内存地址是否相等， ==判断值是否相等

2、深copy和浅copy
    浅copy的特点是:修改原对象的值不会影响copy对象的值；但修改copy对象的值会影响原对象的值
    浅拷贝创建一个新对象，但不会递归复制对象内部的子对象，而是直接引用原对象中的子对象
    深copy的特点是:修改各自的值，各自不受影响
    深拷贝会递归复制对象及其所有子对象，创建一个完全独立的新对象

3、Python 垃圾回收机制
    3.1 引用计数（Reference Counting）
        Python 使用自动内存管理，主要通过引用计数为主，标记-清除和分代回收为辅的垃圾回收机制来管理内存
        工作原理：
        引用增加：当对象被引用时，计数 +1
        引用减少：当引用失效时，计数 -1
        优点：
        实时性高：引用计数降为 0 时立即回收内存
        简单高效：不需要额外的垃圾回收线程
        缺点：
        循环引用问题（无法回收）：
        a = []; b = []
        a.append(b); b.append(a)  # 循环引用，引用计数永远 ≥1
        额外开销：每次引用操作都要修改计数
    3.2 标记-清除（Mark-and-Sweep）
        解决循环引用问题，Python 的辅助垃圾回收机制。
        工作原理：
        标记阶段：从根对象（全局变量、栈中的变量等）出发，标记所有可达对象
        清除阶段：遍历堆内存，回收所有未被标记的对象（即不可达的循环引用对象）
        特点：
        解决循环引用问题
        比引用计数慢，通常作为备用方案
    3.3 分代回收（Generational GC）
        优化策略，基于"弱代假说"（年轻对象更容易被回收）。
        分代划分：
        第 0 代：新创建的对象
        第 1 代：经历过一次 GC 后存活的对象
        第 2 代：经历过多次 GC 后仍然存活的对象
        回收策略：
        第 0 代 GC 最频繁
        第 1 代 GC 次之
        第 2 代 GC 最少
        优点：
        减少全局 GC 的次数
        提高垃圾回收效率

    3.4 垃圾回收触发时机
        引用计数降为 0：立即回收
        手动调用 gc.collect()
        分代回收阈值达到时（可通过 gc.get_threshold() 查看）
        程序退出时